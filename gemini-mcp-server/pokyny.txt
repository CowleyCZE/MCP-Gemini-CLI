### KROK 1: Aktualizace Python Serveru (`godot_mcp_server.py`)

Přidáme nové nástroje a aktualizujeme popisy.

**Upravte `list_tools` (Přidejte/Nahraďte):**

```python
        # --- ZÁKLADNÍ PRÁCE S UZLY (AKTUALIZOVÁNO) ---
        Tool(
            name="godot_set_property",
            description="Nastaví vlastnost uzlu. NYNÍ PODPORUJE VNOŘENÉ RESOURCES pomocí dvojtečky (např. 'shape:size', 'mesh:material:albedo_color').",
            inputSchema={
                "type": "object",
                "properties": {
                    "node_path": {"type": "string"},
                    "property_name": {"type": "string", "description": "Název (např. 'position' nebo 'shape:size')"},
                    "value": {"description": "Hodnota"}
                },
                "required": ["node_path", "property_name", "value"]
            }
        ),
        Tool(
            name="godot_get_property",
            description="Přečte aktuální hodnotu vlastnosti (i vnořené). Užitečné pro ověření stavu.",
            inputSchema={
                "type": "object",
                "properties": {
                    "node_path": {"type": "string"},
                    "property_name": {"type": "string"}
                },
                "required": ["node_path", "property_name"]
            }
        ),
        Tool(
            name="godot_call_method",
            description="Zavolá libovolnou metodu na uzlu (např. 'look_at', 'apply_impulse').",
            inputSchema={
                "type": "object",
                "properties": {
                    "node_path": {"type": "string"},
                    "method_name": {"type": "string"},
                    "args": {"type": "array", "items": {}, "description": "Seznam argumentů funkce", "default": []}
                },
                "required": ["node_path", "method_name"]
            }
        ),
        Tool(
            name="godot_connect_signal",
            description="Propojí signál z jednoho uzlu na metodu jiného uzlu.",
            inputSchema={
                "type": "object",
                "properties": {
                    "source_path": {"type": "string", "description": "Kdo vysílá (např. Button)"},
                    "signal_name": {"type": "string", "description": "Název signálu (např. 'pressed')"},
                    "target_path": {"type": "string", "description": "Kdo poslouchá"},
                    "method_name": {"type": "string", "description": "Funkce, co se spustí (např. '_on_button_pressed')"}
                },
                "required": ["source_path", "signal_name", "target_path", "method_name"]
            }
        ),
        # --- UI TOOLS (OPS_2D) ---
        Tool(
            name="godot_ui_set_layout",
            description="Nastaví UI Layout Preset (kotvení) pro Control uzly (např. 'full_rect', 'center', 'top_left').",
            inputSchema={
                "type": "object",
                "properties": {
                    "node_path": {"type": "string"},
                    "preset": {
                        "type": "string", 
                        "enum": ["top_left", "top_right", "bottom_left", "bottom_right", "center_left", "center_top", "center_right", "center_bottom", "center", "full_rect", "top_wide", "bottom_wide", "left_wide", "right_wide", "v_center_wide", "h_center_wide"],
                        "description": "Typ layoutu (odpovídá menu Layout v editoru)."
                    }
                },
                "required": ["node_path", "preset"]
            }
        ),
```

**Upravte `call_tool`:**

```python
        elif name == "godot_get_property":
            command = {"cmd": "get_prop", "path": arguments.get("node_path"), "prop": arguments.get("property_name")}
        elif name == "godot_call_method":
            command = {"cmd": "call_method", "path": arguments.get("node_path"), "method": arguments.get("method_name"), "args": arguments.get("args", [])}
        elif name == "godot_connect_signal":
            command = arguments.copy()
            command["cmd"] = "connect_signal"
        elif name == "godot_ui_set_layout":
            command = arguments.copy()
            command["cmd"] = "ui_set_layout"
```

---

### KROK 2: Vylepšení `tcp_server.gd` (Synchronizace a Reflexe)

Zde provedeme ty nejdůležitější změny. Zavedeme `await get_tree().process_frame`, abychom zajistili, že Godot stihl zpracovat příkaz před odesláním odpovědi.

**A. Upravte `process_command` (přidání nových příkazů):**

```gdscript
		"get_prop": return get_property(command)
		"call_method": return call_method(command)
		"connect_signal": return connect_signal(command)
		
		# Delegace UI na ops_2d
		"ui_set_layout": return ops_2d.handle_command(cmd_type, command)
```

**B. Nahraďte funkci `load_scene` (Synchronní verze):**

```gdscript
func load_scene(command: Dictionary) -> String:
	var path = command.get("path", "")
	if not FileAccess.file_exists(path):
		return JSON.stringify({"status": "error", "message": "Soubor neexistuje"})
	
	EditorInterface.open_scene_from_path(path)
	
	# SYNCHRONIZAČNÍ SMYČKA: Čekáme, dokud editor skutečně nenačte novou scénu
	var max_retries = 20 # Čekáme max cca 0.3 sekundy
	while max_retries > 0:
		await get_tree().process_frame # Počkat jeden frame
		var current_root = EditorInterface.get_edited_scene_root()
		if current_root and current_root.scene_file_path == path:
			break # Načteno!
		max_retries -= 1
	
	return JSON.stringify({"status": "ok", "message": "Scéna načtena a připravena"})
```

**C. Nahraďte funkci `create_node` (Synchronní verze):**

```gdscript
func create_node(command: Dictionary) -> String:
	# ... (začátek funkce stejný jako dříve: získání parametrů) ...
	var node_type = command.get("type", "Node3D")
	var node_name = command.get("name", "NewNode")
	var parent_path = command.get("parent", "")
	
	var edited_scene = EditorInterface.get_edited_scene_root()
	if not edited_scene: return JSON.stringify({"status": "error", "message": "Žádná scéna"})
	
	var new_node = create_node_by_type(node_type)
	if not new_node: return JSON.stringify({"status": "error", "message": "Neplatný typ"})
	new_node.name = node_name
	
	var parent = edited_scene
	if parent_path != "":
		parent = edited_scene.get_node_or_null(parent_path)
		if not parent:
			new_node.free()
			return JSON.stringify({"status": "error", "message": "Parent nenalezen"})
	
	parent.add_child(new_node)
	new_node.owner = edited_scene
	
	# SYNCHRONIZACE: Počkáme frame, aby se node zapsal do stromu
	await get_tree().process_frame
	
	# Ověření, že tam fakt je
	if is_instance_valid(new_node):
		return JSON.stringify({"status": "ok", "message": "Node vytvořen", "path": str(new_node.get_path())})
	else:
		return JSON.stringify({"status": "error", "message": "Node byl vytvořen, ale ihned zmizel (chyba enginu?)"})
```

**D. Vylepšená `set_property` (Podpora vnořených properties) a nová `get_property`:**

```gdscript
func set_property(command: Dictionary) -> String:
	var node_path = command.get("path", "")
	var prop_name = command.get("prop", "") # Může být "mesh:material:albedo_color"
	var value = command.get("val")
	
	var node = EditorInterface.get_edited_scene_root().get_node_or_null(node_path)
	if not node: return JSON.stringify({"status": "error", "message": "Node nenalezen"})
	
	var converted_value = convert_value(value, prop_name)
	
	# POUŽITÍ INDEXED SETTERU (řeší vnořené vlastnosti)
	# Godot má metodu set_indexed(), která akceptuje cesty s dvojtečkou
	node.set_indexed(prop_name, converted_value)
	
	# Pro jistotu ověříme
	# var check = node.get_indexed(prop_name)
	
	return JSON.stringify({"status": "ok", "message": "Vlastnost " + prop_name + " nastavena"})

func get_property(command: Dictionary) -> String:
	var node_path = command.get("path", "")
	var prop_name = command.get("prop", "")
	
	var node = EditorInterface.get_edited_scene_root().get_node_or_null(node_path)
	if not node: return JSON.stringify({"status": "error", "message": "Node nenalezen"})
	
	var val = node.get_indexed(prop_name)
	
	# Serializace specifických Godot typů pro JSON
	if val is Vector2: val = [val.x, val.y]
	elif val is Vector3: val = [val.x, val.y, val.z]
	elif val is Color: val = [val.r, val.g, val.b, val.a]
	elif val is Object: val = str(val) # Reference na objekt
	
	return JSON.stringify({"status": "ok", "value": val})
```

**E. Nové funkce `call_method` a `connect_signal`:**

```gdscript
func call_method(command: Dictionary) -> String:
	var path = command.get("path", "")
	var method = command.get("method", "")
	var args = command.get("args", [])
	
	var node = EditorInterface.get_edited_scene_root().get_node_or_null(path)
	if not node: return JSON.stringify({"status": "error", "message": "Node nenalezen"})
	
	if not node.has_method(method):
		return JSON.stringify({"status": "error", "message": "Metoda " + method + " neexistuje"})
	
	# Konverze argumentů (Vector3 z pole atd.)
	var clean_args = []
	for arg in args:
		# Jednoduchá heuristika - vylepšit dle potřeby
		if typeof(arg) == TYPE_ARRAY and arg.size() == 3:
			clean_args.append(Vector3(arg[0], arg[1], arg[2]))
		else:
			clean_args.append(arg)
			
	var result = node.callv(method, clean_args)
	
	# Pokud metoda něco vrací, pošleme to zpět
	var str_res = str(result) if result != null else "void"
	return JSON.stringify({"status": "ok", "result": str_res})

func connect_signal(command: Dictionary) -> String:
	var src_path = command.get("source_path", "")
	var sig_name = command.get("signal_name", "")
	var tgt_path = command.get("target_path", "")
	var method = command.get("method_name", "")
	
	var root = EditorInterface.get_edited_scene_root()
	var src = root.get_node_or_null(src_path)
	var tgt = root.get_node_or_null(tgt_path)
	
	if not src or not tgt: return JSON.stringify({"status": "error", "message": "Uzly nenalezeny"})
	
	if not src.has_signal(sig_name):
		return JSON.stringify({"status": "error", "message": "Signál " + sig_name + " neexistuje"})
		
	if src.is_connected(sig_name, Callable(tgt, method)):
		return JSON.stringify({"status": "ok", "message": "Již propojeno"})
		
	# Godot 4 syntaxe propojení
	src.connect(sig_name, Callable(tgt, method))
	
	# Pro editor je důležité nastavit 'owner', aby se propojení uložilo do .tscn? 
	# Signály se ukládají v rámci scény. Pokud je to runtime editace, funguje to.
	# Pro trvalé uložení v editoru je to složitější, ale connect() v tool scriptu by měl stačit.
	
	return JSON.stringify({"status": "ok", "message": "Signál propojen"})
```

---

### KROK 3: Vylepšení `ops_2d.gd` (UI Layout)

Přidejte tuto funkci do `ops_2d.gd` a zaregistrujte ji v jeho `handle_command`.

```gdscript
# V handle_command přidejte:
"ui_set_layout": return ui_set_layout(command)

# Implementace:
func ui_set_layout(command: Dictionary) -> String:
	var path = command.get("node_path", "")
	var preset_str = command.get("preset", "center")
	
	var node = EditorInterface.get_edited_scene_root().get_node_or_null(path)
	if not node or not (node is Control):
		return JSON.stringify({"status": "error", "message": "Node není Control (UI)"})
	
	# Mapování stringů na konstanty Control.PRESET_*
	var preset = Control.PRESET_CENTER # Default
	
	match preset_str:
		"top_left": preset = Control.PRESET_TOP_LEFT
		"top_right": preset = Control.PRESET_TOP_RIGHT
		"bottom_left": preset = Control.PRESET_BOTTOM_LEFT
		"bottom_right": preset = Control.PRESET_BOTTOM_RIGHT
		"center_left": preset = Control.PRESET_CENTER_LEFT
		"center_top": preset = Control.PRESET_CENTER_TOP
		"center_right": preset = Control.PRESET_CENTER_RIGHT
		"center_bottom": preset = Control.PRESET_CENTER_BOTTOM
		"center": preset = Control.PRESET_CENTER
		"full_rect": preset = Control.PRESET_FULL_RECT
		"top_wide": preset = Control.PRESET_TOP_WIDE
		"bottom_wide": preset = Control.PRESET_BOTTOM_WIDE
		"left_wide": preset = Control.PRESET_LEFT_WIDE
		"right_wide": preset = Control.PRESET_RIGHT_WIDE
		"v_center_wide": preset = Control.PRESET_VCENTER_WIDE
		"h_center_wide": preset = Control.PRESET_HCENTER_WIDE
	
	node.set_anchors_preset(preset)
	
	return JSON.stringify({"status": "ok", "message": "Layout nastaven na " + preset_str})
```